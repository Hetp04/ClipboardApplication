import React, { useState, useEffect, useRef, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { listen } from "@tauri-apps/api/event";
// import Groq from "groq-sdk"; // Import Groq if you have the SDK, otherwise use fetch
import '../styles/MainScreen.css';
import hljs from 'highlight.js'; // Use standard highlight.js import
import Sidebar from './Sidebar'; // Import the Sidebar component
import * as chrono from 'chrono-node'; // Import chrono library for date parsing with named import

// Define types for snippets
interface BaseSnippet {
  id: string;
  type: string;
  content: string;
  source: string;
  timestamp: string;
  tags: string[];
  notes?: string[]; // Array of strings for bullet points
  isFavorite?: boolean;
  sourceApp?: {
    name: string;
    base64_icon?: string; // Add the base64 icon field
  };
}

interface CodeSnippet extends BaseSnippet {
  type: 'code';
  path: string;
}

interface TweetSnippet extends BaseSnippet {
  type: 'tweet';
  handle: string;
}

interface QuoteSnippet extends BaseSnippet {
  type: 'quote';
  author: string;
}

interface LinkSnippet extends BaseSnippet {
  type: 'link';
  title: string;
}

interface TextSnippet extends BaseSnippet {
  type: 'text';
}

interface MessageSnippet extends BaseSnippet {
  type: 'message';
  contact: string;
}

type Snippet = CodeSnippet | TweetSnippet | QuoteSnippet | LinkSnippet | TextSnippet | MessageSnippet;

// Sample snippet data for demo mode
const demoSnippets: Snippet[] = [
  {
    id: 'demo-1',
    type: 'code',
    content: `const fetchUserData = async (userId) => {
  try {
    const response = await api.get(\`/users/\${userId}\`);
    return response.data;
  } catch (error) {
    console.error('Error fetching user data:', error);
    return null;
  }
};`,
    source: 'VS Code',
    path: 'src/utils/api.ts',
    timestamp: 'May 2, 2025 · 2:34 PM',
    tags: ['typescript', 'react', 'api']
  },
  {
    id: 'demo-2',
    type: 'tweet',
    content: 'Just launched our new design system! Check out how we\'re using Figma and React to create a seamless workflow between design and development. #designsystem #frontend',
    source: 'Twitter',
    handle: '@designer',
    timestamp: 'May 2, 2025 · 1:15 PM',
    tags: ['design', 'announcement']
  },
  {
    id: 'demo-3',
    type: 'quote',
    content: 'The best way to predict the future is to invent it. The future is not laid out on a track. It is something that we can decide, and to the extent that we do not violate any known laws of the universe, we can probably make it work the way that we want to.',
    source: 'Medium',
    author: 'Alan Kay',
    timestamp: 'May 1, 2025 · 11:22 AM',
    tags: ['inspiration', 'quote']
  },
  {
    id: 'demo-4',
    type: 'text',
    content: 'Pick up groceries: eggs, milk, bread, avocados, chicken, pasta',
    source: 'Notes',
    timestamp: 'May 1, 2025 · 9:42 AM',
    tags: ['todo']
  },
  {
    id: 'demo-5',
    type: 'link',
    content: 'https://react.dev/reference/react',
    source: 'Browser',
    title: 'React Documentation',
    timestamp: 'April 30, 2025 · 4:18 PM',
    tags: ['resource', 'reference', 'react']
  },
  {
    id: 'demo-6',
    type: 'message',
    content: 'Hey, can you send me the latest design mockups for the dashboard? I need to implement those changes by Friday.',
    source: 'iMessage',
    contact: 'Alex Chen',
    timestamp: 'April 30, 2025 · 1:35 PM',
    tags: ['work', 'design']
  }
];

// Helper function to format timestamp
const formatTimestamp = (date: Date): string => {
  return date.toLocaleDateString('en-US', {
    month: 'long',
    day: 'numeric',
    year: 'numeric',
  }) + ' · ' + date.toLocaleTimeString('en-US', {
    hour: 'numeric',
    minute: '2-digit',
    hour12: true,
  });
};

// Improved heuristic check for code patterns with more robust detection
const looksLikeCode = (text: string): boolean => {
  // Avoid treating error messages as code
  if (text.includes("Failed to load resource") || 
      text.includes("Error processing query") ||
      text.includes("(Bad Request)") ||
      text.includes("HTTP status code")) {
    return false;
  }
  
  // Check for common code patterns
  const codePatterns = [
    // Function definitions
    /function\s+\w+\s*\(/i,
    // Method definitions
    /\w+\s*\(\s*\)\s*{/i,
    // Class definitions
    /class\s+\w+/i,
    // Variable declarations
    /(const|let|var)\s+\w+\s*=/i,
    // Import statements
    /import\s+[\w{},\s*]+\s+from/i,
    // HTML tags pairs
    /<\w+[^>]*>[\s\S]*?<\/\w+>/i,
    // Self-closing HTML tags
    /<\w+[^>]*\/>/i,
    // CSS rules
    /\.\w+\s*{[^}]+}/i,
    // JavaScript objects
    /{\s*\w+:\s*[^{}]+}/i,
  ];

  // Return true if any code pattern is found
  return codePatterns.some(pattern => pattern.test(text));
};

// Function to try to detect language with highlight.js
const detectLanguageWithHljs = (text: string): string | null => {
  try {
    // Skip very short snippets, highlightAuto can be unreliable on tiny fragments
    if (text.trim().length < 20) return null;
    
    // Remove markdown code block syntax if present
    const cleanedText = text.replace(/^```\w*\n|\n```$/g, '');
    
    // Strong language markers that can quickly identify a language with high confidence
    const languageMarkers: {[key: string]: RegExp[]} = {
      'python': [
        /\bdef\s+\w+\s*\(.*\):\s*$/m,
        /\bimport\s+\w+(\.\w+)*(\s+as\s+\w+)?/,
        /^\s*if\s+__name__\s*==\s*['"]__main__['"]\s*:/m
      ],
      'javascript': [
        /\bconst\s+\w+\s*=|let\s+\w+\s*=|var\s+\w+\s*=|\bfunction\s+\w+\s*\(/,
        /\bnew\s+Promise\s*\(|\basync\s+function|\bawait\s+/,
        /\bdocument\.getElementById\s*\(|\bwindow\./
      ],
      'typescript': [
        /\binterface\s+\w+\s*\{|\btype\s+\w+\s*=|\b\w+\s*:\s*(string|number|boolean|any)\b/,
        /\w+<\w+(\[\])?>/
      ],
      'html': [
        /<!DOCTYPE\s+html>|<html[^>]*>|<body[^>]*>|<div[^>]*>/i,
        /<\/?[a-z][\s\S]*>/i
      ],
      'css': [
        /[.#][\w-]+\s*\{[^}]*\}/,
        /@media\s+/,
        /\b(margin|padding|border|color|background|font-size|width|height)\s*:/
      ],
      'java': [
        /\bpublic\s+(static\s+)?(void|class|interface)\b/,
        /\bSystem\.out\.println\(/,
        /\bimport\s+java\./
      ],
      'c++': [
        /#include\s*<[^>]+>/,
        /\bstd::\w+/,
        /\bnamespace\s+\w+/
      ],
      'csharp': [
        /\busing\s+System;/,
        /\bnamespace\s+\w+/,
        /\bConsole\.Write(Line)?\(/
      ],
      'rust': [
        /\bfn\s+\w+/,
        /\blet\s+mut\s+\w+/,
        /\bimpl\s+\w+\s+for\s+\w+/
      ],
      'go': [
        /\bpackage\s+main/,
        /\bfunc\s+\w+/,
        /\bfmt\.(Print|Println|Printf)\(/
      ],
      'sql': [
        /\bSELECT\s+.+?\s+FROM\s+/i,
        /\bCREATE\s+TABLE\s+/i,
        /\bINSERT\s+INTO\s+/i
      ],
      'php': [
        /<\?php/,
        /\becho\s+/,
        /\$\w+\s*=/
      ],
      'ruby': [
        /\bdef\s+\w+(\(.+\))?\s*\n/,
        /\bclass\s+\w+(\s+<\s+\w+)?/,
        /\bend\b/
      ],
      'bash': [
        /^#!/,
        /\becho\s+["']/,
        /\$\(\w+\)/
      ]
    };
    
    // First try a quick check for strong language markers
    for (const [language, patterns] of Object.entries(languageMarkers)) {
      if (patterns.some(pattern => pattern.test(cleanedText))) {
        return language;
      }
    }
    
    // If no strong markers matched, use highlight.js auto detection
    const result = hljs.highlightAuto(cleanedText, [
      'javascript', 'typescript', 'python', 'java', 'html', 'css', 'cpp', 
      'csharp', 'go', 'rust', 'bash', 'shell', 'json', 'xml', 'php', 'swift',
      'kotlin', 'ruby', 'sql', 'yaml', 'markdown'
    ]);
    
    // Require a higher relevance threshold for reliable detection
    if (result.language && result.relevance > 8) {
      // Map highlight.js language identifier to simpler tag name if needed
      const languageMap: {[key: string]: string} = {
        'csharp': 'c#',
        'cpp': 'c++',
        'js': 'javascript',
        'ts': 'typescript',
        'py': 'python',
        // Add more mappings if needed
      };
      
      return languageMap[result.language] || result.language;
    }
    
    return null; // Couldn't detect with enough confidence
  } catch (error) {
    console.error("❌ Error in highlight.js detection:", error);
    return null;
  }
};

// Define a separate component for the notes section to maintain focus
const NotesInputSection = ({ snippet, addNote, removeNote }: {
  snippet: Snippet;
  addNote: (snippet: Snippet, note: string) => void;
  removeNote: (snippetId: string, noteIndex: number) => void;
}) => {
  const [inputValue, setInputValue] = useState('');
  const inputRef = useRef<HTMLInputElement>(null);
  
  // Handle note input change
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
  };
  
  // Handle key press (Enter to add note)
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && inputValue.trim()) {
      e.preventDefault();
      addNote(snippet, inputValue);
      setInputValue('');
    }
  };
  
  // Handle add button click
  const handleAddClick = () => {
    if (inputValue.trim()) {
      addNote(snippet, inputValue);
      setInputValue('');
      // Focus back on input after adding
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }
  };
  
  return (
    <div className="notes-section">
      <div className="note-input-container">
        <input
          ref={inputRef}
          type="text"
          className="note-input"
          placeholder="Add a note..."
          value={inputValue}
          onChange={handleInputChange}
          onKeyPress={handleKeyPress}
        />
        <button 
          className="add-note-btn"
          onClick={handleAddClick}
          disabled={!inputValue.trim()}
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
          </svg>
        </button>
      </div>
      
      {snippet.notes && snippet.notes.length > 0 && (
        <ul className="notes-list">
          {snippet.notes.map((note, index) => (
            <li key={index} className="note-item">
              <span className="note-text">{note}</span>
              <button 
                className="remove-note-btn"
                onClick={() => removeNote(snippet.id, index)}
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

// Helper function to load snippets initially
const loadInitialSnippets = (): Snippet[] => {
  try {
    console.log('[Load] Attempting to load snippets from localStorage...');
    const savedSnippets = localStorage.getItem('saved_snippets');
    if (savedSnippets) {
      const parsedSnippets = JSON.parse(savedSnippets) as Snippet[];
      console.log(`[Load] Successfully loaded ${parsedSnippets.length} snippets from localStorage.`);
      return parsedSnippets;
    } else {
      console.log('[Load] No saved snippets found in localStorage.');
      return [];
    }
  } catch (error) {
    console.error('❌ [Load] Error loading snippets from localStorage:', error);
    return []; // Return empty array if not found or error occurs
  }
};

interface ParsedFilters {
  keywords?: string[];
  contentType?: string;
  alternativeTypes?: string[]; // Added for AI-based type matching
  codeContext?: {
    language?: string;
    functionality?: string;
    visualElements?: string[];
    algorithm?: string;
    problem?: string;
    output?: string;
  };
  source?: string;
  dateContext?: {
    from: string;
    to: string;
    fromTime?: string;
    toTime?: string;
    hasTimeComponent?: boolean;
  };
  // Keep for backward compatibility 
  date?: {
    from: string;
    to: string;
  };
  // Keep for backward compatibility
  type?: string;
  // Keep for backward compatibility
  app?: string;
  attributes?: {
    favorite?: boolean;
  };
  searchTerms?: {
    term: string;
    importance?: number;
    alternatives?: string[];
    partialMatching?: boolean;
  }[];
  understanding?: {
    userIntent: string;
    searchType: 'code' | 'text' | 'link' | 'image' | 'general';
    codeRelated: boolean;
  };
  codeAnalysis?: {
    functionality: string;
    possibleSyntaxPatterns?: string[];
    expectedOutput: string;
    relatedConcepts?: string[];
  };
}

const MainScreen: React.FC = () => {
  const navigate = useNavigate();
  const [isDemoMode, setIsDemoMode] = useState(false);
  const [capturedSnippets, setCapturedSnippets] = useState<Snippet[]>(loadInitialSnippets());
  const [copiedId, setCopiedId] = useState<string | null>(null);
  const [searchInput, setSearchInput] = useState('');
  const [activeView, setActiveView] = useState<'all' | 'favorites' | 'tags' | 'trash'>('all');
  const [selectedApp, setSelectedApp] = useState('all');
  const [isAppFilterOpen, setIsAppFilterOpen] = useState(false);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  
  // Smart search state variables
  const [isSmartSearch, setIsSmartSearch] = useState(false);
  const [isSearching, setIsSearching] = useState<boolean>(false);
  const [processedDateQuery, setProcessedDateQuery] = useState<string | null>(null);
  const [isCommandsDropdownOpen, setIsCommandsDropdownOpen] = useState(false);
  
  // Enhanced structured search filters
  const [parsedFilters, setParsedFilters] = useState<ParsedFilters | null>(null);
  
  // For date sorting
  const [sortOrder, setSortOrder] = useState<'desc' | 'asc'>('desc');
  const [sortType, setSortType] = useState<'newest' | 'oldest'>('newest');

  const sortByNewest = (a: Snippet, b: Snippet) => {
    return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
  };
  
  const sortByOldest = (a: Snippet, b: Snippet) => {
    return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
  };
  
  // Additional state and refs that were removed
  const lastCaptureRef = useRef<{ text: string, timestamp: number, fromCopyButton: boolean }>({
    text: '',
    timestamp: 0,
    fromCopyButton: false
  });
  const hasLoadedRef = useRef(false);
  const [editingNotesIds, setEditingNotesIds] = useState<string[]>([]);
  const [currentNote, setCurrentNote] = useState('');
  const noteInputRef = useRef<HTMLInputElement>(null);

  // Gemini API Key - Use environment variable or fallback to provided key
  const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY || "AIzaSyDtNstUTBzr3sx1RfUvJQZfYWJgVf8DbKw";
  
  // Simple API response cache
  const apiCache = useRef<{[key: string]: any}>({});
  
  // Gemini API helper with caching and retry logic
  const callGeminiAPI = async (prompt: string, model: string = "gemini-1.0-pro", attempts: number = 2): Promise<any> => {
    const cacheKey = `${model}:${prompt.substring(0, 50)}`;
    
    // Check cache first
    if (apiCache.current[cacheKey]) {
      console.log("🔄 Using cached response");
      return apiCache.current[cacheKey];
    }
    
    let lastError = null;
    
    for (let attempt = 1; attempt <= attempts; attempt++) {
      try {
        // Add delay for retry attempts
        if (attempt > 1) {
          const delay = (attempt - 1) * 2000; // Increasing delay
          console.log(`⏱️ Rate limit hit. Retry in ${delay/1000}s...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
        
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`, {
          method: "POST",
          headers: {
            "x-goog-api-key": GEMINI_API_KEY,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            contents: [
              {
                role: "user",
                parts: [{ text: prompt }]
              }
            ],
            generationConfig: {
              temperature: 0.1,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: 1024
            }
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`❌ Error from Gemini API (${response.status}):`, errorText);
          
          // If it's a rate limit error, retry
          if (response.status === 429) {
            lastError = new Error(`Rate limit: ${response.status} ${errorText}`);
            continue; // Try again
          }
          
          throw new Error(`API error: ${response.status} ${errorText}`);
        }
        
        const result = await response.json();
        if (!result.candidates || result.candidates.length === 0) {
          throw new Error("Empty response from Gemini API");
        }
        
        // Cache successful response
        apiCache.current[cacheKey] = result;
        return result;
      } catch (error) {
        lastError = error;
        if (attempt >= attempts || !(error instanceof Error && error.message.includes("Rate limit"))) {
          throw error;
        }
      }
    }
    
    throw lastError;
  };

  // Fix the processCommandInput function
  const processCommandInput = async (value: string) => {
    // Reset state when changing command
    setSearchInput(value);
    
    if (value.startsWith('/')) {
      // Handle date command
      if (value.startsWith('/date')) {
        const dateQuery = value.substring(5).trim();
        if (dateQuery) {
          const processedQuery = await processDateQueryWithAI(dateQuery);
          console.log('Processed date query:', processedQuery);
        } else {
          setProcessedDateQuery(null);
          setParsedFilters(null);
        }
        return;
      }
      
      // Handle type command
      if (value.startsWith('/type')) {
        const typeQuery = value.substring(5).trim();
        if (typeQuery) {
          // Use AI to understand the type query
          const parsedFilters = await processTypeQueryWithAI(typeQuery);
          
          // Directly filter snippets based on the parsed filters
          if (parsedFilters) {
            // const filteredResults = capturedSnippets.filter(snippet => 
            //   matchesTypeQuery(snippet, parsedFilters)
            // );
            // REMOVED incorrect setCapturedSnippets call
            return; // Rely on useMemo hook update
          }
        } else {
          // Reset filters if no query
          setParsedFilters(null);
          // REMOVED incorrect setCapturedSnippets call
          return; // Rely on useMemo hook update
        }
      }
      
      // Handle app command
      if (value.startsWith('/app')) {
        // Process app filter
        const appQuery = value.substring(4).trim();
        if (appQuery) {
          // Filter logic will be handled by useMemo reacting to searchInput change
          // const filtered = capturedSnippets.filter(snippet => matchesAppQuery(snippet, appQuery));
          // REMOVED incorrect setCapturedSnippets call
          return; // Rely on useMemo hook update
        }
      }
      
      // Handle smart command (AI query understanding)
      if (value.startsWith('/smart')) {
        const smartQuery = value.substring(6).trim();
        if (smartQuery) {
          await processSmartQueryWithAI(smartQuery);
        }
        return;
      }
      
      // Handle favorite command
      if (value.startsWith('/fav')) {
        // Filter logic will be handled by useMemo reacting to activeView change (needs adjustment in Sidebar/view logic if /fav is typed directly)
        // For now, just setting activeView seems more appropriate than direct filtering here
        setActiveView('favorites'); // Assuming this triggers useMemo correctly
        // const favSnippets = capturedSnippets.filter(snippet => snippet.isFavorite);
        // REMOVED incorrect setCapturedSnippets call
        return; // Rely on useMemo hook update
      }
      
      // Handle custom commands that appear in dropdown
      if (value === '/newest') {
        setSortType('newest');
        return;
      }
      
      if (value === '/oldest') {
        setSortType('oldest');
        return;
      }
      
      // Handle unknown command
      console.log(`Unknown command: ${value}`);
    } else {
      // Reset any active filters when doing a normal search
      setParsedFilters(null);
      setProcessedDateQuery(null);
      
      // Handle normal search
      const filtered = basicTextMatch(capturedSnippets, value.toLowerCase());
      setCapturedSnippets(filtered);
    }
  };

  // Helper function to get semantic matches for types
  const getTypeSemanticMatches = (word: string): string[] => {
    const typeSemantics: {[key: string]: string[]} = {
      "code": ["code", "script", "function", "snippet", "programming", "algorithm", "javascript", "python", "html", "css"],
      "url": ["url", "link", "website", "site", "webpage", "http", "https", "web", "github", "youtube"],
      "image": ["image", "picture", "photo", "screenshot", "diagram", "chart", "graph", "png", "jpg", "jpeg"],
      "file": ["file", "document", "pdf", "spreadsheet", "excel", "word", "powerpoint", "presentation", "doc", "csv"],
      "text": ["text", "note", "message", "content", "paragraph", "article", "essay", "discussion", "conversation"]
    };
    
    for (const [type, semantics] of Object.entries(typeSemantics)) {
      if (semantics.includes(word) || semantics.some(term => term.includes(word) || word.includes(term))) {
        return [type];
      }
    }
    
    return [];
  };
  
  // Utility function for debouncing
  function debounce<F extends (...args: any[]) => any>(func: F, waitFor: number) {
    let timeout: ReturnType<typeof setTimeout> | null = null;
    
    return (...args: Parameters<F>): void => {
      if (timeout !== null) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => func(...args), waitFor);
    };
  }

  // New function for real-time semantic search
  const performRealTimeSearch = debounce((query: string) => {
    console.log("Performing real-time semantic search:", query);
    
    if (!query || query.length < 2) {
      setCapturedSnippets(loadInitialSnippets());
      return;
    }
    
    // Normalize the query for comparison
    const normalizedQuery = query.toLowerCase().trim();
    const queryWords = normalizedQuery.split(/\s+/).filter(w => w.length > 2 && !isStopWord(w));
    
    // Create a map of words to their importance
    const wordImportance: Map<string, number> = new Map();
    
    // Assign importance to each word based on frequency and position
    queryWords.forEach((word, index) => {
      // Words at the beginning are likely more important
      const positionWeight = 1 - (index / (queryWords.length * 2));
      // Longer words tend to carry more meaning
      const lengthWeight = Math.min(1, word.length / 10);
      
      const importance = 1 + positionWeight + lengthWeight;
      wordImportance.set(word, importance);
    });
    
    // Score each snippet based on semantic relevance
    const scoredSnippets = capturedSnippets.map((snippet: Snippet) => {
      const content = snippet.content.toLowerCase();
      const source = snippet.source.toLowerCase();
      const snippetType = snippet.type.toLowerCase();
      
      // Different content fields have different weights
      const weights = {
        content: 1.0,
        source: 0.5,
        type: 0.4,
        notes: 0.7
      };
      
      let score = 0;
      
      // Check for direct substring matches first (high relevance)
      if (content.includes(normalizedQuery)) {
        score += normalizedQuery.length * 0.5 * weights.content;
      }
      
      if (source.includes(normalizedQuery)) {
        score += normalizedQuery.length * 0.3 * weights.source;
      }
      
      // Calculate semantic score based on individual words
      for (const [word, importance] of wordImportance.entries()) {
        // Check content
        if (content.includes(word)) {
          // Calculate how central the word is in the content
          const wordIndex = content.indexOf(word);
          const centralityFactor = 1 - Math.min(1, Math.abs(content.length/2 - wordIndex) / (content.length/2));
          
          // More central matches are more relevant
          score += importance * weights.content * (1 + centralityFactor);
          
          // Add extra score for whole word matches
          if (new RegExp(`\\b${word}\\b`).test(content)) {
            score += importance * 0.5 * weights.content;
          }
        }
        
        // Check source
        if (source.includes(word)) {
          score += importance * weights.source;
          
          // Add extra score for whole word matches
          if (new RegExp(`\\b${word}\\b`).test(source)) {
            score += importance * 0.5 * weights.source;
          }
        }
        
        // Check type semantics (e.g., "website" should match "url" type)
        if (getTypeSemanticMatches(word).includes(snippetType)) {
          score += importance * weights.type * 2; // Higher weight for semantic type matches
        }
        
        // Check notes if they exist
        if (snippet.notes && snippet.notes.length > 0) {
          const notesText = snippet.notes.join(' ').toLowerCase();
          if (notesText.includes(word)) {
            score += importance * weights.notes;
          }
        }
      }
      
      // Recency boost - newer items get a slight advantage
      const timestamp = new Date(snippet.timestamp).getTime();
      const now = Date.now();
      const recencyBoost = Math.min(0.2, (now - timestamp) / (1000 * 60 * 60 * 24 * 30)); // Max 0.2 for items within a month
      
      score += recencyBoost;
      
      return { snippet, score };
    });
    
    // Filter out low-scoring snippets and sort by score
    const threshold = 0.5; // Minimum relevance score
    const relevantSnippets = scoredSnippets
      .filter((item: {snippet: Snippet, score: number}) => item.score > threshold)
      .sort((a: {snippet: Snippet, score: number}, b: {snippet: Snippet, score: number}) => b.score - a.score)
      .map((item: {snippet: Snippet, score: number}) => item.snippet);
    
    // If no results with high relevance, fallback to more permissive matching
    if (relevantSnippets.length === 0) {
      const basicMatches = basicTextMatch(capturedSnippets, normalizedQuery);
      setCapturedSnippets(basicMatches);
    } else {
      setCapturedSnippets(relevantSnippets);
    }
  }, 150); // debounce for better performance

  // Enhanced function to handle search input changes with real-time semantic analysis
  const handleSearchInputChange = async (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const value = e.target.value;
    setSearchInput(value);
    
    // Early return if query is empty or just being initialized
    if (!value.trim()) {
      setCapturedSnippets(loadInitialSnippets());
      return;
    }

    // If the user starts with a slash, it's a command
    if (value.startsWith('/')) {
      processCommandInput(value);
      return;
    }
    
    // Real-time semantic analysis for standard queries
    performRealTimeSearch(value);
  };

  const processTypeQueryWithAI = async (query: string): Promise<ParsedFilters | null> => {
    try {
      console.log(`🧰 [TypeAPI] Processing type query with Gemini: "${query}"`);
      setIsSearching(true);
      
      const prompt = `You are a specialized AI working in a clipboard application that needs to understand the intent behind a search query and extract structured filters.

Your job is to analyze this search query: "${query}"

Extract the following structured information for filtering:
1. Content type or format the user is looking for (code, link, text, tweet, message, quote)
2. Alternative types that might match the user's intent (list of types)
3. Source application if mentioned or implied (Slack, Chrome, etc.)
4. Date context if mentioned (from/to dates, time ranges)
5. Keywords that are important for matching content

Additional context requirements:
1. For code queries - detect programming language, functionality, frameworks mentioned
2. For text content - identify tone, format, importance markers
3. Look for app source mentions like "from slack" or "in chrome"

If multiple content types might match, prioritize the most specific.

IMPORTANT: Return ONLY a JSON object with these fields:
{
  "contentType": string or null,  
  "alternativeTypes": string[] or null,
  "source": string or null,
  "dateContext": {
    "from": ISO date string,
    "to": ISO date string,
    "fromTime": "HH:MM:SS" or null,
    "toTime": "HH:MM:SS" or null,
    "hasTimeComponent": boolean
  } or null,
  "keywords": string[] or null
}

If a field isn't relevant/detected, set it to null. All dates must be in ISO format.`;

      // Use the helper function instead of direct API call for better rate limit handling
      const result = await callGeminiAPI(prompt);
      
      // Extract text from response
      const aiResponse = result.candidates[0].content.parts[0].text;
      console.log('AI response:', aiResponse);

      // Extract the JSON part from the response (handling potential explanation text)
      let jsonStr = aiResponse;
      if (aiResponse.includes('{') && aiResponse.includes('}')) {
        jsonStr = aiResponse.substring(
          aiResponse.indexOf('{'),
          aiResponse.lastIndexOf('}') + 1
        );
      }

      // Parse the JSON
      const parsedFilters = JSON.parse(jsonStr);
      
      console.log('Parsed filters:', parsedFilters);
      console.log('Parsed filters being set:', parsedFilters);
      
      // Store the parsed filters in state for other components to use
      setParsedFilters(parsedFilters);
      
      return parsedFilters;
    } catch (error) {
      console.error("❌ Error in processTypeQueryWithAI:", error);
      setIsSearching(false);
      return null;
    } finally {
      setIsSearching(false);
    }
  };

  const processDateQueryWithAI = async (query: string): Promise<string | null> => {
    try {
      console.log(`📆 [DateAPI] Processing date query with Gemini: "${query}"`);
      setIsSearching(true);
      
      const prompt = `You are a specialized Date Extraction AI for a clipboard manager application.

Your task is to extract precise date and time ranges from this user query: "${query}"

INSTRUCTIONS:
1. Parse the query and identify any date/time references
2. Convert relative dates (today, yesterday, last week, etc.) to actual dates
3. Always return a "from" and "to" date representing the range
4. Include time components if specified or implied

RESPONSE FORMAT:
Return ONLY a JSON object with:
{
  "from": "YYYY-MM-DD",  // ISO date string for start of range
  "to": "YYYY-MM-DD",    // ISO date string for end of range
  "fromTime": "HH:MM:SS", // Optional time component for start
  "toTime": "HH:MM:SS",   // Optional time component for end
  "hasTimeComponent": boolean // Whether time was part of the query
}

For single days, set both from/to to the same date.
For "today", use today's date.
For "yesterday", use yesterday's date.
For "last week", calculate dates for previous week.
For months, use the full month range.
For years, use the full year range.
For quarters (Q1,Q2,etc), calculate correct date ranges.

Today's date for reference: ${new Date().toISOString().split('T')[0]}`;

      // Use the helper function instead of direct API call
      const result = await callGeminiAPI(prompt);
      
      // Extract text from response
      const responseText = result.candidates[0].content.parts[0].text;
      
      if (responseText) {
        console.log("✓ Received Gemini date parsing result:", responseText);
        
        try {
          // Extract the JSON part from the response
          let jsonStr = responseText;
          if (responseText.includes('{') && responseText.includes('}')) {
            jsonStr = responseText.substring(
              responseText.indexOf('{'),
              responseText.lastIndexOf('}') + 1
            );
          }
          
          // Parse into an object
          const dateInfo = JSON.parse(jsonStr);
          
          // Set the processed date query for filtering
          if (dateInfo && dateInfo.from && dateInfo.to) {
            console.log("✓ Successfully parsed date range:", dateInfo);
            
            // Create a proper date filter structure in parsed filters
            const dateFilters: ParsedFilters = {
              dateContext: {
                from: dateInfo.from,
                to: dateInfo.to,
                fromTime: dateInfo.fromTime || null,
                toTime: dateInfo.toTime || null,
                hasTimeComponent: !!dateInfo.hasTimeComponent
              }
            };
            
            // Update the parsed filters state
            setParsedFilters(dateFilters);
            
            // Return the dateInfo as JSON for backward compatibility
            return JSON.stringify(dateInfo);
          } else {
            console.error("❌ Invalid date structure from Gemini:", dateInfo);
          }
        } catch (parseError) {
          console.error("❌ Error parsing Gemini date response:", parseError);
          console.log("Raw response:", responseText);
        }
      }
    } catch (error) {
      console.error("❌ Error calling Gemini API:", error);
    } finally {
      setIsSearching(false);
    }
    
    // All parsing failed
    console.log("⚠️ All date parsing methods failed - returning original query");
    return query;
  };

  const processSmartQueryWithAI = async (query: string): Promise<void> => {
    try {
      console.log("🧠 Calling Gemini API for smart query understanding...");
      
      const prompt = `You are QueryUnderstanding, an AI expert in analyzing search queries for a clipboard manager application.

I need you to analyze this search query and extract the user's search intent:

Query: "${query}"

Analyze this query and extract:
1. What content the user is looking for (code, text, messages, links, images, etc.)
2. Any time/date filters implied
3. Any app source mentioned or implied (Chrome, Slack, etc.)
4. Important keywords/subjects that would help with semantic search

Return a structured JSON response with the following format:
{
  "parsedFilters": {
    "contentType": string or null,
    "alternativeTypes": string array,
    "source": string or null,
    "dateContext": {
      "from": ISO date string,
      "to": ISO date string,
      "fromTime": "HH:MM:SS" or null,
      "toTime": "HH:MM:SS" or null,
      "hasTimeComponent": boolean
    } or null,
    "keywords": string array or null
  },
  "understanding": {
    "userIntent": string,
    "searchType": "code"|"text"|"link"|"image"|"general",
    "codeRelated": boolean
  }
}

IMPORTANT: Return ONLY valid JSON. No prefacing or additional text.`;

      // Use the helper function
      const result = await callGeminiAPI(prompt);

      // Extract text from response
      const responseText = result.candidates[0].content.parts[0].text;
        
      if (responseText) {
        console.log("✓ Received Gemini smart query understanding:", responseText);
        
        try {
          // Extract the JSON part from the response (handling potential explanation text)
          let jsonStr = responseText;
          if (responseText.includes('{') && responseText.includes('}')) {
            jsonStr = responseText.substring(
              responseText.indexOf('{'),
              responseText.lastIndexOf('}') + 1
            );
          }
          
          // Parse the JSON
          const aiResult = JSON.parse(jsonStr);
          console.log("Parsed AI result:", aiResult);
          
          if (aiResult && aiResult.parsedFilters) {
            console.log("Setting parsed filters from smart query:", aiResult.parsedFilters);
            setParsedFilters(aiResult.parsedFilters);
          }
          
          // Apply the AI filters if we got any
          if (aiResult && aiResult.parsedFilters) {
            console.log("✅ AI query understanding successful");
          } else {
            console.error("❌ AI response missing parsedFilters property");
          }
        } catch (parseError) {
          console.error("❌ Error parsing AI response:", parseError);
        }
      }
    } catch (error) {
      console.error("❌ Error in smart query processing:", error);
    } finally {
      setIsSearching(false);
    }
  };

  return (
    <div className="main-screen-container">
      {/* Only show Sidebar if there are snippets and NOT in demo mode */}
      {(capturedSnippets.length > 0 && !isDemoMode) && (
        <Sidebar 
          isCollapsed={sidebarCollapsed} 
          toggleSidebar={toggleSidebar}
          activeView={activeView}
          onViewChange={setActiveView}
        />
      )}
      
      <div className={`main-content ${(capturedSnippets.length > 0 && !isDemoMode) ? (sidebarCollapsed ? 'sidebar-collapsed' : 'sidebar-expanded') : ''}`}>
        <div className="main-screen">
          {/* back button removed */}
          
          {/* Add Delete All Button */}
          {capturedSnippets.length > 0 && !isDemoMode && (
            <button 
              className="delete-all-btn"
              onClick={handleDeleteAll}
              title="Delete all captured snippets"
            >
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M3 6h18"></path>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
              </svg>
              Clear All
            </button>
          )}

          {isDemoMode ? (
            <div className="demo-mode-container">
              <div className="demo-mode-header">
                <span className="demo-badge">Demo Mode</span>
                <button className="exit-demo-btn" onClick={toggleDemoMode}>
                  Exit Demo
                </button>
                <p className="demo-subtitle">This is a demonstration of the clipboard history UI. In the full app, your clipboard items appear here.</p>
              </div>

              <div className="snippets-container">
                <div className="snippets-column">
                  {demoSnippets.filter((_, index) => index % 2 === 0).map(snippet => (
                    <div key={snippet.id} className="snippet-wrapper">
                      {renderSnippetCard(snippet, handleDeleteSnippet)}
                    </div>
                  ))}
                </div>
                <div className="snippets-column">
                  {demoSnippets.filter((_, index) => index % 2 === 1).map(snippet => (
                    <div key={snippet.id} className="snippet-wrapper">
                      {renderSnippetCard(snippet, handleDeleteSnippet)}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ) : (
            <div className="captured-snippets-container demo-mode-container">
              {/* Sort Control */}
              {capturedSnippets.length > 0 && !isDemoMode && (
                <div className="controls-container">
                  <AppFilter />
                  <div className="search-bar">
                    <svg className="search-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <circle cx="11" cy="11" r="8"></circle>
                      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    <svg 
                      className={`wand-icon ${isSmartSearch ? 'active' : ''}`}
                      xmlns="http://www.w3.org/2000/svg" 
                      width="24" 
                      height="24" 
                      viewBox="0 0 24 24" 
                      fill="none" 
                      stroke="currentColor" 
                      strokeWidth="2" 
                      strokeLinecap="round" 
                      strokeLinejoin="round"
                      onClick={handleMagicSearch}
                    >
                      <title>Toggle smart search</title>
                      <path d="M15 4V2"></path>
                      <path d="M15 16v-2"></path>
                      <path d="M8 9h2"></path>
                      <path d="M20 9h2"></path>
                      <path d="M17.8 11.8L19 13"></path>
                      <path d="M15 9h0"></path>
                      <path d="M17.8 6.2L19 5"></path>
                      <path d="M12.2 6.2L11 5"></path>
                      <path d="M12.2 11.8L11 13"></path>
                      <path d="M5 19l7-7"></path>
                    </svg>
                    
                    {isSmartSearch && (
                      <button 
                        className="view-commands-btn" 
                        onClick={toggleCommandsDropdown}
                        aria-label="View smart search commands"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <line x1="4" y1="9" x2="20" y2="9"></line>
                          <line x1="4" y1="15" x2="20" y2="15"></line>
                          <line x1="10" y1="3" x2="8" y2="21"></line>
                          <line x1="16" y1="3" x2="14" y2="21"></line>
                        </svg>
                        <span>Commands</span>
                      </button>
                    )}
                    
                    {isCommandsDropdownOpen && (
                      <div className="commands-dropdown">
                        <div className="commands-header">Smart search commands</div>
                        <div className="command-item" onClick={() => handleCommandSelect('/date')}>
                          <span className="command">/date</span>
                          <span className="description">Filter by when the item was copied</span>
                        </div>
                        <div className="command-item" onClick={() => handleCommandSelect('/type')}>
                          <span className="command">/type</span>
                          <span className="description">Filter by content type (text, image, URL, code)</span>
                        </div>
                        <div className="commands-tip">
                          <p>Or just type naturally:</p>
                          <p><em>"Show me code from yesterday"</em></p>
                        </div>
                      </div>
                    )}
                    
                    <textarea 
                      placeholder={isSmartSearch ? "Try 'code from yesterday' or '/date last week'..." : "Search clips..."}
                      className={`search-input ${isSmartSearch ? 'smart-search-active' : ''} ${(searchInput.startsWith('/date') || searchInput.startsWith('/type')) ? 'has-command' : ''}`}
                      value={searchInput}
                      onChange={handleSearchInputChange}
                      title={searchInput}
                      rows={1}
                      onInput={(e) => {
                        // Auto-resize textarea
                        const target = e.target as HTMLTextAreaElement;
                        target.style.height = 'auto';
                        target.style.height = Math.min(target.scrollHeight, 100) + 'px';
                      }}
                    />
                    
                    {isSearching && (
                      <div className="search-loading">
                        <svg className="spinner" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <line x1="12" y1="2" x2="12" y2="6"></line>
                          <line x1="12" y1="18" x2="12" y2="22"></line>
                          <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
                          <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
                          <line x1="2" y1="12" x2="6" y2="12"></line>
                          <line x1="18" y1="12" x2="22" y2="12"></line>
                          <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line>
                          <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>
                        </svg>
                        <span>AI processing...</span>
                      </div>
                    )}
                    
                    {searchInput && (
                      <button 
                        className="clear-search-btn" 
                        onClick={() => {
                          setSearchInput('');
                        }}
                        aria-label="Clear search"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <line x1="18" y1="6" x2="6" y2="18"></line>
                          <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                      </button>
                    )}
                  </div>
                  <div className="sort-control">
                    <button 
                      className={`sort-btn ${sortOrder === 'desc' ? 'active' : ''}`}
                      onClick={() => setSortOrder('desc')}
                      aria-label="Sort by newest first"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M3 4h13M3 8h9M3 12h5M11 16L7 20M7 16l-4 4M21 4v16"/>
                      </svg>
                      Newest
                    </button>
                    <button 
                      className={`sort-btn ${sortOrder === 'asc' ? 'active' : ''}`}
                      onClick={() => setSortOrder('asc')}
                      aria-label="Sort by oldest first"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M3 4h13M3 8h9M3 12h5M11 16l4 4M15 16l4 4M21 4v16"/>
                      </svg>
                      Oldest
                    </button>
                  </div>
                </div>
              )}
              
              {activeView === 'favorites' && sortedSnippets.length === 0 ? (
                <div className="empty-favorites">
                  <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
                    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                  </svg>
                  <h3>No favorites yet</h3>
                  <p>Click the star icon on any snippet to add it to your favorites</p>
                </div>
              ) : capturedSnippets.length === 0 && !isDemoMode ? (
                <div className="empty-state">
                  <div className="icon-container">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                  </div>
                  <h2>Your clipboard history will appear here</h2>
                  <p>Copy some text to get started, or try out the demo to see how it works.</p>
                  <button className="demo-btn" onClick={toggleDemoMode}>
                    Try Demo Mode
                  </button>
                </div>
              ) : sortedSnippets.length === 0 && searchInput.trim() ? (
                <div className="empty-state">
                  <div className="icon-container">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
                      <circle cx="11" cy="11" r="8"></circle>
                      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                  </div>
                  <h2>No results found</h2>
                  {isSmartSearch && searchInput.trim().startsWith('/date') ? (
                    <p>No clips match your date search for "{searchInput.substring(5).trim()}". Try a different date expression.</p>
                  ) : (
                    <p>No clips match your search for "{searchInput}". Try a different search term.</p>
                  )}
                </div>
              ) : (
                <div className="snippets-container">
                  {/* Removed date filter indicator */}
                  <div className="snippets-column">
                    {sortedSnippets.filter((_, index) => index % 2 === 0).map(snippet => (
                      <div key={snippet.id} className="snippet-wrapper">
                        {renderSnippetCard(snippet, handleDeleteSnippet)}
                      </div>
                    ))}
                  </div>
                  <div className="snippets-column">
                    {sortedSnippets.filter((_, index) => index % 2 === 1).map(snippet => (
                      <div key={snippet.id} className="snippet-wrapper">
                        {renderSnippetCard(snippet, handleDeleteSnippet)}
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default MainScreen; 

